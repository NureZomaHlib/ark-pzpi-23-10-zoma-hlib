МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
Кафедра «Програмна інженерія»






ЗВІТ
з практичної роботи №1
з дисципліни «Аналіз та рефакторінг коду»
на тему «Основні рекомендації написання коду для мови програмування R»








Виконав:                                                           	     Перевірив:
ст. гр. ПЗПІ-23-10                                                       Старший викл. Кафедри ПІ
Зьома Г.Я.                                                              	     Сокорчук І.П.




Харків 2025
1. ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень112.10.250.1Зроблено основні розділи215.10.250.2Додано слайди презентації та програмний код322.10.250.3Додаємо відеозапис та хронологічний опис2. 

   2. ЗАВДАННЯ
      Метою даної роботи є комплексне опанування принципів написання якісного, зрозумілого та ефективного коду на мові програмування Kotlin. Завдання полягає не лише у вивченні теоретичних основ стилю кодування, але й у формуванні практичних навичок їх застосування під час реальної розробки. Ключовим аспектом є демонстрація того, як суворе дотримання принципів чистого коду – включаючи чітке іменування, правильне структурування, використання переваг null-safety, функцій вищого порядку та сучасних мовних конструкцій – безпосередньо впливає на якість програмного забезпечення. Важливо показати, що послідовне застосування цих підходів дозволяє уникнути типових помилок, значно підвищує читабельність та підтримуваність коду, спрощує процес рефакторингу та тестування, а також створює основу для ефективної командної роботи. Опанування цих навичок є невід’ємною складовою підготовки сучасного розробника та забезпечує здатність створювати надійний, гнучкий і професійний програмний код.


3. ОПИС ВИКОНАНОЇ РОБОТИ
1. 
2. 
     2.1. Вступ
     Метою даної роботи є вивчення основних принципів та рекомендацій написання якісного програмного коду на мові програмування Kotlin. У сучасних умовах стрімкого розвитку інформаційних технологій особливої актуальності набувають питання стандартизації та якості програмного забезпечення. Kotlin як сучасна мова програмування, що поєднує об'єктно-орієнтований та функціональний підходи, вимагає дотримання певних правил кодування для забезпечення ефективності розробки. У роботі розглядаються ключові аспекти написання чистого коду, включаючи правила іменування, структурування проектів, використання сучасних мовних конструкцій та документування. Особлива увага приділяється практичному застосуванню отриманих знань у реальних умовах розробки програмного забезпечення.
     2.2.  Причини важливості правил оформлення коду
     Дотримання єдиного стилю коду є фундаментальною вимогою для створення якісного програмного забезпечення. Послідовне застосування стандартів кодування значно підвищує ефективність командної роботи, дозволяючи розробникам швидше розуміти логіку колег та без проблем інтегрувати свої модулі в загальну структуру проекту. Чіткі правила сприяють зменшенню кількості помилок, оскільки усувають неоднозначність у тлумаченні коду. Процеси рефакторингу та тестування також значно прискорюються завдяки чіткій структурі та організації коду. Наприклад, код з незрозумілими назвами та відсутністю форматування ускладнює розуміння, тоді як чітко структурований код із зрозумілими іменами значно покращує читабельність.
     2.3. Структура коду в Kotlin
     Правильна організація структури коду є ключовим фактором успішної розробки. Для підтримуваності коду необхідно розділяти його на логічні блоки: класи, функції, модулі. Використання пакетів для групування споріднених елементів дозволяє створити зрозумілу архітектуру проекту. Кожен файл повинен містити лише споріднену функціональність, об'єднану спільним призначенням. Такий підхід робить код модульним, легшим для тестування та розробки. Короткі та зрозумілі файли спрощують навігацію по кодовій базі та пришвидшують роботу над проектом, особливо на етапі його масштабування. Правильна структура дозволяє легко знаходити потрібні компоненти та вносити зміни, не порушуючи роботу інших частин системи.
     2.4. Іменування у Kotlin
     Правила іменування є одним з найважливіших інструментів створення самодокументованого коду. Використання camelCase для змінних і функцій, PascalCase для класів і інтерфейсів, UPPER_SNAKE_CASE для констант робить код зрозумілим та інтуїтивним. Назви мають бути інформативними та повністю відображати призначення об'єкта. Слід уникати беззмістовних скорочень та однолітерних імен, оскільки вони ускладнюють розуміння коду. Правильне іменування також сприяє легшому пошуку потрібних елементів у великій кодовій базі.
     2.5. Коментарі та документація
     Ефективне використання коментарів та документації є важливою складовою професійної розробки. Коментарі мають пояснювати складну бізнес-логіку або неочевидні рішення, а не констатувати очевидні речі. Для документування функцій і класів слід використовувати KDoc - стандартний інструмент документації в Kotlin. Не рекомендується залишати закоментований старий код, оскільки він створює плутанину та погіршує читабельність. Кожен коментар має бути коротким, зрозумілим та інформативним. Добре написані коментарі допомагають новим розробникам швидше зрозуміти логіку роботи програми.
     2.6. Використання типів і Null-safety
     Система типів та механізми безпеки щодо null-значень є потужними інструментами Kotlin для запобігання помилок. Рекомендується завжди явно вказувати типи, особливо коли вони не очевидні з контексту. Важливо правильно використовувати val для незмінних посилань та var лише для змінних, що дійсно змінюються. Null-safe оператори (?. для безпечних викликів, ?: для значень за замовчуванням) дозволяють уникнути класичних NullPointerException. Слід уникати використання оператора !! через його потенційну небезпеку. Правильне використання системи типів робить код більш безпечним і передбачуваним.
     2.7. Функції та лямбди
     Функції в Kotlin повинні бути короткими та виконувати одну конкретну дію, що підвищує їх тестованість та можливість повторного використання. Слід уникати дублювання коду шляхом винесення спільної логіки в окремі функції. Для простих операцій рекомендується використовувати лямбда-вирази, що робить код більш компактним. Функції вищого порядку, такі як map, filter, forEach, дозволяють замінити традиційні цикли на більш виразні та безпечні конструкції. Такий підхід робить код чистішим та зменшує його обсяг.
     2.8. Рефакторинг та підтримка коду
     Рефакторинг є невід'ємною частиною процесу розробки, спрямованою на постійне покращення якості коду. Регулярне проведення рефакторингу дозволяє поліпшити внутрішню структуру програми без зміни її зовнішньої поведінки. Важливо видаляти дублюючий та застарілий код, що зменшує складність системи та полегшує її супроводження. Довгі функції слід розбивати на менші, зрозумілі блоки, кожен з яких виконує певну логічну операцію. Використання зрозумілих назв змінних і функцій значно полегшує процес рефакторингу, оскільки робить наміри розробника очевидними для всіх учасників проекту. Наприклад, розділення великої функції на кілька дрібних з чіткими назвами покращує читабельність та спрощує тестування.
     2.9. Обробка помилок
     Правильна обробка помилок є важливою для створення стабільних та надійних додатків. Для перехоплення передбачуваних винятків слід використовувати try-catch блоки. Блоки catch ніколи не повинні залишатися порожніми, оскільки це призводить до "мовчазного" поглинання помилок. Не рекомендується використання оператора !! через ризик виникнення NullPointerException. Важливо писати зрозумілі повідомлення про помилки, які дозволяють швидко визначити причину та місце виникнення проблеми. У випадках, коли стандартних винятків недостатньо, варто створювати власні типи винятків для точнішого відображення специфічних помилкових ситуацій.
     2.10. Практичні поради для чистого коду 
     Для створення чистого коду слід дотримуватися принципу DRY (Don't Repeat Yourself), спрямованого на усунення дублювання коду шляхом його повторного використання. Важливо використовувати стандартні бібліотеки Kotlin замість власних реалізацій, що зменшує кількість помилок та прискорює розробку. Функції повинні бути невеликими та однозначними, що полегшує їх тестування та супроводження. Для критичних частин системи обов'язковим є написання тестів, що забезпечує їх стабільність. Використання зрозумілих імен змінних і функцій робить код самодокументованим та зменшує необхідність у коментарях.

4. ВИСНОВКИ
      Проведена робота з вивчення основних рекомендацій написання коду на Kotlin дозволила чітко визначити ключові принципи створення якісного програмного забезпечення. Дотримання єдиного стилю кодування, правил іменування змінних і функцій, а також правильна організація структури проекту є фундаментальними вимогами для написання чистого, читабельного та підтримуваного коду. Особливе значення має послідовне застосування цих принципів у командній роботі, оскільки це безпосередньо впливає на ефективність співпраці, зменшення кількості помилок та прискорення процесів розробки.
      Важливим аспектом є використання сучасних інструментів та підходів, які пропонує мова Kotlin. Механізми null-safety, функції вищого порядку, лямбда-вирази та ефективна обробка винятків дозволяють створювати безпечний та надійний код. Регулярний рефакторинг, усунення дублювання коду, написання тестів для критичних частин системи - все це сприяє підвищенню якості програмного забезпечення. Використання принципу DRY та стандартних бібліотек Kotlin значно спрощує процес розробки та зменшує його трудомісткість.
      У підсумку, освоєння найкращих практик програмування на Kotlin є необхідною умовою для створення сучасного, конкурентоздатного програмного забезпечення. Чистий код не лише полегшує супроводження та розширення проекту, але й сприяє професійному зростанню розробника. Дотримання вивчених принципів дозволить створювати програмні продукти, які відповідають вимогам сучасного ринку та забезпечують стабільну роботу в довгостроковій перспектив.


      
5. СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ
     1. Офіційна документація Kotlin: https://kotlinlang.org/docs/coding-conventions.html (date of access: 03.10.2025)
     2. Clean code with Kotlin: https://phauer.com/2017/clean-code-kotlin/ (date of access: 08.10.2025)
     3. Exceptions in Kotlin: https://kotlinlang.org/docs/exceptions.html (date of access 10.10.2025)
     4. Kotlin design patterns and best practices: https://www.packtpub.com/en-us/product/kotlin-design-patterns-and-best-practices-9781805127765 (date of access 10.10.2025)


ДОДАТОК А
Посилання відео на Youtube
Відеозапис доповіді: https://www.youtube.com/watch?v=ZIFPFB6SqBs
Хронологічний опис відеозапису:
0:00 - Вступ 
0:49 - Чому важливо дотримуватись стилю коду 
1:47 - Структура коду 
2:58 - Іменування 
4:03 - Коментарі та документація 
5:02 - Використання типів і Null-safety 
5:40 - Функції та лямбди в Kotlin
6:39 - Рефакторинг та підтримка коду
7:22 - Обробка помилок у Kotlin 
8:16 - Практичні поради для чистого коду
9:08 - Висновки.


ДОДАТОК Б
Слайди презентації

Рисунок Б.1 – Титульний лист


Рисунок Б.2 – Вступ

Рисунок Б.3 – Важливість дотримання стилю коду


Рисунок Б.4 – Структура коду

Рисунок Б.5 – Іменування

Рисунок Б.6 – Коментарі та документація

Рисунок Б.7 – Використання типів і Null-safety


Рисунок Б.8 – Функції та лямбди в Kotlin


Рисунок Б.9 – Рефакторинг та підтримка коду


Рисунок Б.10 – Обробка помилок у Kotlin


Рисунок Б.11 – Практичні поради для чистого коду


Рисунок Б.12 – Висновки


Рисунок Б.13 - Джерела



ДОДАТОК В
Програмний код
В.1 Поганий і хороший стиль коду
GitHub репозиторій: https://github.com/NureZomaHlib/ark-pzpi-23-10-zoma-hlib/blob/main/Pract1/pzpi-23-10-zoma-hlib-pract1/code-examples-code-conventions.kt 
1  // Погано
2  fun f(a:Int,b:Int)=a+b // незрозуміла назва, немає відступів
3
4  // Добре
5  fun calculateSum(a: Int, b: Int): Int {
6    return a + b
7  }

В.2 Зрозумілі імена змінних, функцій, класів
GitHub репозиторій: https://github.com/NureZomaHlib/ark-pzpi-23-10-zoma-hlib/blob/main/Pract1/pzpi-23-10-zoma-hlib-pract1/code-examples-code-conventions.kt 
1  // Погано
2  var x = "Ivan" // незрозуміле ім’я
3  fun f(a: Int, b: Int) = a + b // невідомо, що робить функція
4  class u {
5    var n: String = "" // незрозуміле ім’я
6  }
7  const val m = 100 // незрозуміла константа
8
9  // Добре
10  val userName = "Ivan"
11  fun calculateSum(a: Int, b: Int) = a + b
12  class User(val name: String)
13  const val MAX_USERS = 100

В.3 Іменування
GitHub репозиторій: https://github.com/NureZomaHlib/ark-pzpi-23-10-zoma-hlib/blob/main/Pract1/pzpi-23-10-zoma-hlib-pract1/code-examples-code-conventions.kt 
1  // Погано
2  var x = "Ivan" // незрозуміле ім’я
3  fun f(a: Int, b: Int) = a + b // невідомо, що робить функція
4  class u {
5    var n: String = "" // незрозуміле ім’я
6  }
7  const val m = 100 // незрозуміла константа
8
9  // Добре
10  val userName = "Ivan"
11  fun calculateSum(a: Int, b: Int) = a + b
12  class User(val name: String)
13  const val MAX_USERS = 100

В.4 Коментарі та документація
GitHub репозиторій: https://github.com/NureZomaHlib/ark-pzpi-23-10-zoma-hlib/blob/main/Pract1/pzpi-23-10-zoma-hlib-pract1/code-examples-code-conventions.kt 
1  // Погано
2  // функція для додавання
3  fun sum(a: Int, b: Int): Int {
4    // додаємо два числа
5    return a + b
6  }
7
8  // Добре
9  /**
10   * Обчислює суму двох чисел
11   * @param a перше число
12   * @param b друге число
13   * @return результат додавання
14   */
15  fun sum(a: Int, b: Int): Int {
16    return a + b
17  }

В.5 Використання типів і Null-safety
GitHub репозиторій: https://github.com/NureZomaHlib/ark-pzpi-23-10-zoma-hlib/blob/main/Pract1/pzpi-23-10-zoma-hlib-pract1/code-examples-code-conventions.kt 
1  // Погано
2  var name // тип не вказаний
3  name = null // може бути NullPointerException
4  var age: Int? = null
5  val years = age!! // аварійне розіменування
6
7  // Добре
8  val name: String? = null // явно вказаний nullable-тип
9  val age: Int? = null
10  val years = age ?: 0 // безпечна заміна значенням за замовчуванням
11  val length = name?.length // безпечний виклик

В.6 Функції та лямбди в Kotlin
GitHub репозиторій: https://github.com/NureZomaHlib/ark-pzpi-23-10-zoma-hlib/blob/main/Pract1/pzpi-23-10-zoma-hlib-pract1/code-examples-code-conventions.kt 
1  // Погано
2  fun process(list: List<Int>): List<Int> {
3    val result = mutableListOf<Int>()
4    for (i in list) {
5      if (i % 2 == 0) {
6        result.add(i * 2)
7      }
8    }
9    return result
10  }
11
12  // Добре
13  fun process(list: List<Int>): List<Int> =
14    list.filter { it % 2 == 0 }
15      .map { it * 2 }

В.7 Рефакторинг та підтримка коду
GitHub репозиторій: https://github.com/NureZomaHlib/ark-pzpi-23-10-zoma-hlib/blob/main/Pract1/pzpi-23-10-zoma-hlib-pract1/code-examples-code-conventions.kt 
1  // Погано
2  fun doEverything() {
3    val a = 10
4    val b = 20
5    val c = a + b
6    println(c)
7  }
8
9  // Добре
10  fun calculateSum(a: Int, b: Int) = a + b
11  fun printSum(a: Int, b: Int) {
12    val sum = calculateSum(a, b)
13    println(sum)
14  }

В.8 Обробка помилок у Kotlin
GitHub репозиторій: https://github.com/NureZomaHlib/ark-pzpi-23-10-zoma-hlib/blob/main/Pract1/pzpi-23-10-zoma-hlib-pract1/code-examples-code-conventions.kt 
1  // Погано
2  val input: String? = null
3  println(input!!.length)
4  try {
5    val x = 10 / 0
6  } catch (e: Exception) {
7    // порожній catch
8  }
9
10  // Добре
11  val input: String? = null
12  val length = input?.length ?: 0
13  try {
14    val x = 10 / 0
15  } catch (e: ArithmeticException) {
16    println("Ділення на нуль: ${e.message}")
17  }

В.9 Практичні поради для чистого коду
GitHub репозиторій: https://github.com/NureZomaHlib/ark-pzpi-23-10-zoma-hlib/blob/main/Pract1/pzpi-23-10-zoma-hlib-pract1/code-examples-code-conventions.kt 
1  // Погано
2  fun calculate() {
3    val a = 10 + 20
4    val b = 10 + 20
5    val c = 10 + 20
6    println(a + b + c)
7  }
8
9  // Добре
10  fun sum(a: Int, b: Int) = a + b
11  fun calculate() {
12    val x = sum(10, 20)
13    val y = sum(10, 20)
14    val z = sum(10, 20)
15    println(x + y + z)
16  }
25


